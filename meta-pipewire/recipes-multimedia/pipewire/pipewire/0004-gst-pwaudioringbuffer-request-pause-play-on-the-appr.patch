From 1027efb2ced95a9548007ccc2f07805d48073846 Mon Sep 17 00:00:00 2001
From: George Kiagiadakis <george.kiagiadakis@collabora.com>
Date: Thu, 11 Jul 2019 16:21:17 +0300
Subject: [PATCH] gst/pwaudioringbuffer: request pause/play on the appropriate
 stream state changes

This allows the client to properly go to PAUSED when the session manager
unlinks the stream and go again to PLAYING when the sm re-links it.
This allows the session manager to implement policies without letting
the client pipeline freeze (in the absence of a running audio clock)
when it is unlinked. Note that in case the client doesn't handle the
request, there is still no issue. Like in pulseaudio, the clock just
freezes, so the pipeline stops progressing.

This is similar to the pulseaudio cork/uncork mechanism.

Upstream-Status: Denied
See https://gitlab.freedesktop.org/pipewire/pipewire/merge_requests/140
---
 src/gst/gstpwaudioringbuffer.c | 27 +++++++++++++++++++++++----
 1 file changed, 23 insertions(+), 4 deletions(-)

diff --git a/src/gst/gstpwaudioringbuffer.c b/src/gst/gstpwaudioringbuffer.c
index 989b2cd7..97350f38 100644
--- a/src/gst/gstpwaudioringbuffer.c
+++ b/src/gst/gstpwaudioringbuffer.c
@@ -202,11 +202,16 @@ on_stream_state_changed (void *data, enum pw_stream_state old,
     enum pw_stream_state state, const char *error)
 {
   GstPwAudioRingBuffer *self = GST_PW_AUDIO_RING_BUFFER (data);
+  GstMessage *msg;
 
   GST_DEBUG_OBJECT (self->elem, "got stream state: %s",
       pw_stream_state_as_string (state));
 
   switch (state) {
+    case PW_STREAM_STATE_ERROR:
+      GST_ELEMENT_ERROR (self->elem, RESOURCE, FAILED,
+          ("stream error: %s", error), (NULL));
+      break;
     case PW_STREAM_STATE_UNCONNECTED:
       GST_ELEMENT_ERROR (self->elem, RESOURCE, FAILED,
           ("stream disconnected unexpectedly"), (NULL));
@@ -214,12 +219,26 @@ on_stream_state_changed (void *data, enum pw_stream_state old,
     case PW_STREAM_STATE_CONNECTING:
     case PW_STREAM_STATE_CONFIGURE:
     case PW_STREAM_STATE_READY:
+      break;
     case PW_STREAM_STATE_PAUSED:
-    case PW_STREAM_STATE_STREAMING:
+      if (old == PW_STREAM_STATE_STREAMING) {
+        if (GST_STATE (self->elem) != GST_STATE_PAUSED &&
+            GST_STATE_TARGET (self->elem) != GST_STATE_PAUSED) {
+          GST_DEBUG_OBJECT (self->elem, "requesting GST_STATE_PAUSED");
+          msg = gst_message_new_request_state (GST_OBJECT (self->elem),
+              GST_STATE_PAUSED);
+          gst_element_post_message (self->elem, msg);
+        }
+      }
       break;
-    case PW_STREAM_STATE_ERROR:
-      GST_ELEMENT_ERROR (self->elem, RESOURCE, FAILED,
-          ("stream error: %s", error), (NULL));
+    case PW_STREAM_STATE_STREAMING:
+      if (GST_STATE (self->elem) != GST_STATE_PLAYING &&
+          GST_STATE_TARGET (self->elem) != GST_STATE_PLAYING) {
+        GST_DEBUG_OBJECT (self->elem, "requesting GST_STATE_PLAYING");
+        msg = gst_message_new_request_state (GST_OBJECT (self->elem),
+            GST_STATE_PLAYING);
+        gst_element_post_message (self->elem, msg);
+      }
       break;
   }
   pw_thread_loop_signal (self->main_loop, FALSE);
-- 
2.24.0

